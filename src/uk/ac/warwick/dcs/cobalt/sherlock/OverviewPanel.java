package uk.ac.warwick.dcs.cobalt.sherlock;

import java.io.*;
import java.util.*;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.awt.print.*;
import javax.swing.*;

/**
 * An overview of a detection result of a pair of submissions. This view can
 * link to selected match pairs.<p>
 * This frame is printable.
 *
 * @author Weiliang Zhang
 * @version 25 Sep 2002
 */
public class OverviewPanel
    extends JPanel
    implements Printable, MouseListener {
  /**
   * Original submitted files.
   */
  private File[] files;

  /**
   * Matches for this pair.
   */
  private LinkedList matches;

  /**
   * ComparePane showing the source files.
   */
  private ComparePane cp;

  /**
   * Number of lines in original files.
   */
  private int[] lines = new int[2];

  /**
   * TOP LEFT CORNER COORDINATES FOR THE RECTANGLES.
   */
  private int[] x = new int[2];
  private final int y = 80;

  /**
   * CONSTANTS FOR RECTANGLE DIMENSIONS, used together with respective
   * ratios for fit into a panel.
   */
  private final int FILEWIDTH = 100;
  private final int LINEWIDTH = 80;

  /**
   * Linked list holding matched sections.
   */
  private LinkedList pairList;

  /**
   * Linked list holding the lines which link pairs of sections.
   */
  private LinkedList linelist;

  /**
   * Line widths. Wider lines are used for file boundries.
   */
  private static final BasicStroke normal = new BasicStroke(4.0f);
  private static final BasicStroke wide = new BasicStroke(8.0f);

  /**
   * Graphical representation of a match, each section is represented
   * as a rectangle.
   */
  private class MatchPair {
    /**
     * Section in file 1
     */
    private Rectangle2D rect1;

    /**
     * Section in file 2
     */
    private Rectangle2D rect2;

    /**
     * Match represented by this pair.
     */
    private Match match;

    public MatchPair(Match m, Rectangle2D r1, Rectangle2D r2) {
      match = m;
      rect1 = r1;
      rect2 = r2;
    }

    public Match getMatch() {
      return match;
    }

    public Rectangle2D getRect1() {
      return rect1;
    }

    public Rectangle2D getRect2() {
      return rect2;
    }

    /**
     * Check whether this point is in either of the rectangles.
     */
    public boolean contains(double x, double y) {
      return rect1.contains(x, y) || rect2.contains(x, y);
    }
  }

//     /**
//      * Construct an overview directly from an array of 3 files.
//      *
//      * @param f File array of size 3, containing the 2 original source code
//      * files, and a match file in the order specified.
//      */
//     public OverviewPanel(File[] f) {
// 	if (f.length == 0)
// 	    return;

// 	files = f;
// 	String file1, file2;
// 	try {
// 	    LinkedList ms = new LinkedList();
// 	    for (int i = 2; i < files.length; i++) {
// 		ObjectInputStream in = new ObjectInputStream
// 		    (new FileInputStream(files[i]));
// 		Match m = (Match) in.readObject();
// 		if (file1 == null) {
// 		    file1 = m.getFile1();
// 		    file2 = m.getFile2();
// 		}
// 		ms.add(m);
// 		in.close();
// 	    }

// 	    this(ms, file1, file2, null);
// 	}
// 	catch (IOException e) {
// 	    System.out.println("Cannot read from file");
// 	    e.printStackTrace();
// 	}
// 	catch (ClassNotFoundException e) {
// 	    System.out.println("cannot deserialise");
// 	}
//     }

  /**
   * Construct an overview panel for a selected pair.
   * <p> The reason why filenames are not generated by this class is that
   * the linked list passed to it may be empty.
   *
   * @param matches all matches for this pair.
   * @param file1 filename for the first file in this pair.
   * @param file2 filename for the second file in this pair.
   * @param cp ComparePane showing the souce files.
   */
  public OverviewPanel(LinkedList matches, String file1, String file2,
                       ComparePane cp) {
    setBackground(Color.white);
    this.matches = matches;
    this.cp = cp;

    pairList = new LinkedList();
    linelist = new LinkedList();

    //the imaginary paper width is 400, leaving 50 margins on both sides.
    x[0] = 50;
    x[1] = 250;

    files = new File[2];
    files[0] = new File
        (Settings.sourceDirectory + Settings.fileSep
         + Settings.fileTypes[Settings.ORI].getDirectory(),
         file1 + "." +
         Settings.fileTypes[Settings.ORI].getExtension());
    files[1] = new File
        (Settings.sourceDirectory + Settings.fileSep
         + Settings.fileTypes[Settings.ORI].getDirectory(),
         file2 + "." +
         Settings.fileTypes[Settings.ORI].getExtension());

    //count number of lines in original files.
    String tmp = null;
    for (int i = 0; i < files.length; i++) {
      try {
        BufferedReader br = new BufferedReader
            (new FileReader(files[i]));
        lines[i] = 0;
        //count the number of lines in file.
        while ( (tmp = br.readLine()) != null) {
          lines[i]++;
        }
      }
      catch (IOException e) {
        JOptionPane.showMessageDialog
            (this, "Cannot read file: " + files[i].getAbsolutePath(),
             "Failed to read from file", JOptionPane.ERROR_MESSAGE);
        return;
      }
    }

    //construct matched sections
    ListIterator itr = matches.listIterator();
    while (itr.hasNext()) {
      Match m = (Match) itr.next();
      int length1 = m.getRun().getEndCoordinates()
          .getOrigLineNoInFile1()
          - m.getRun().getStartCoordinates()
          .getOrigLineNoInFile1();
      int length2 = m.getRun().getEndCoordinates()
          .getOrigLineNoInFile2()
          - m.getRun().getStartCoordinates()
          .getOrigLineNoInFile2();

      //add sections & lines to linked list
      Rectangle2D r1 = new Rectangle2D.Float
          (x[0] + 10, y + m.getRun().getStartCoordinates()
           .getOrigLineNoInFile1(), LINEWIDTH, length1);
      Rectangle2D r2 = new Rectangle2D.Float
          (x[1] + 10, y + m.getRun().getStartCoordinates()
           .getOrigLineNoInFile2(), LINEWIDTH, length2);
      pairList.add(new MatchPair(m, r1, r2));

      linelist.add(new Line2D.Float
                   (x[0] + FILEWIDTH - 10,
                    y + m.getRun().getStartCoordinates()
                    .getOrigLineNoInFile1() + length1 / 2,
                    x[1] + 10,
                    y + m.getRun().getStartCoordinates()
                    .getOrigLineNoInFile2() + length2 / 2));
    }

    addMouseListener(this);
  }

  /**
   * Extract original file name from preprocessed filenames. It also removes
   * the directory information.
   */
  private String truncate(String arg) {
    File file = new File(arg);
    String str = file.getName();
    int index = str.lastIndexOf(".");
    str = str.substring(0, index);
    return str;
  }

  public void paintComponent(Graphics g) {
    Graphics2D g2 = (Graphics2D) g;

    //scale to fit on current panel.
    double yscale = 1.0d;
    if (lines[0] > lines[1]) {
      yscale = (double) getHeight() / ( (double) lines[0] / 0.75);
    }
    else {
      yscale = (double) getHeight() / ( (double) lines[1] / 0.75);
    }
    double xscale = (double) getWidth() / 400.0d;

    g2.scale(xscale, yscale);

    //turn on antialiasing.
    RenderingHints antialiasing = new RenderingHints
        (RenderingHints.KEY_ANTIALIASING,
         RenderingHints.VALUE_ANTIALIAS_ON);
    g2.addRenderingHints(antialiasing);

    //draw string labels
    g2.setStroke(normal);
    g2.drawString(files[0].getName(), x[0],
                  y - g2.getFontMetrics().getHeight());
    g2.drawString(files[1].getName(), x[1],
                  y - g2.getFontMetrics().getHeight());

    //draw file boundries
    g2.setStroke(wide);
    for (int i = 0; i < 2; i++) {
      Rectangle2D rect = new Rectangle2D.Float
          (x[i], y, FILEWIDTH, lines[i]);
      g2.draw(rect);
      g2.setColor(Color.lightGray);
      g2.fill(rect);
      g2.setColor(Color.black);
    }

    //draw sections
    g2.setStroke(normal);
    ListIterator itr = pairList.listIterator();
    while (itr.hasNext()) {
      MatchPair pair = (MatchPair) itr.next();
      Rectangle2D r = pair.getRect1();
      //	    System.out.println(r.toString());
      g2.draw(r);
      g2.setColor(Color.yellow);
      g2.fill(r);
      g2.setColor(Color.black);
      r = pair.getRect2();
      g2.draw(r);
      g2.setColor(Color.yellow);
      g2.fill(r);
      g2.setColor(Color.black);
    }

    //draw lines to link sections
    itr = linelist.listIterator();
    while (itr.hasNext()) {
      g2.draw( (Line2D) itr.next());

    }
    g2.dispose();
    g.dispose();
  }

  public int print(Graphics g, PageFormat pageFormat,
                   int pageIndex) throws PrinterException {
    Graphics2D g2 = (Graphics2D) g;
    g2.setColor(Color.black);
    int fontHeight = g2.getFontMetrics().getHeight();
    int fontDesent = g2.getFontMetrics().getDescent();

    //leave room for page number
    double pageHeight =
        pageFormat.getImageableHeight() - fontHeight;
    double pageWidth =
        pageFormat.getImageableWidth();

    double width = getWidth();
    double height = getHeight();
    double yscale = 1.0;
    double xscale = 1.0;
    if (height > pageHeight) {
      yscale = height / pageHeight;
    }
    else {
      yscale = pageHeight / height;

    }
    if (width > pageWidth) {
      xscale = width / pageWidth;
    }
    else {
      xscale = pageWidth / width;

    }
    g2.translate(0.0d, 0.0d);
    g2.setClip(0, 0, (int) pageWidth, (int) pageHeight);
    g2.scale(xscale, yscale);
    paint(g2);

    g2.dispose();
    g.dispose();
    return Printable.PAGE_EXISTS;
  }

  /**
   * Double click on a section will load this match pair in the ComparePane
   */
  public void mouseClicked(MouseEvent e) {
    //catch only double clicks.
    if (e.getClickCount() != 2) {
      return;
    }

    //find point
    Point p = e.getPoint();
    double yscale = 1;
    if (lines[0] > lines[1]) {
      yscale = (double) getHeight() / ( (double) lines[0] / 0.75);
    }
    else {
      yscale = (double) getHeight() / ( (double) lines[1] / 0.75);
    }
    double xscale = (double) getWidth() / 400.0d;
    //scale to original model.
    double x = p.getX() / xscale;
    double y = p.getY() / yscale;

    //check all sections.
    ListIterator itr = pairList.listIterator();
    while (itr.hasNext()) {
      MatchPair pair = (MatchPair) itr.next();
      //if this is the selected match, load it.
      if (pair.contains(x, y)) {
        cp.load(pair.getMatch());
        break;
      }
    }
  }

  public void mousePressed(MouseEvent e) {}

  public void mouseEntered(MouseEvent e) {}

  public void mouseExited(MouseEvent e) {}

  public void mouseReleased(MouseEvent e) {}
}
