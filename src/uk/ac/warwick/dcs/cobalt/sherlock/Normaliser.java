/* Generated By:JavaCC: Do not edit this line. Normaliser.java */
package uk.ac.warwick.dcs.cobalt.sherlock;
import java.io.*;
import java.util.Date;

public class Normaliser implements NormaliserConstants {
  //line number in the original file
  public static int lineNo = 1;

  //when counter hits MAX, output line number.
  private static int counter = 0;
  private final static int MAX = 10;

  //brackets count only count brackets in the same line.
  public static int brackets = 0;
  //indicate at the start of a new line. 
  private static boolean startOfNewLine = true;

  private static boolean wasspace = false;

  private static File outputFile;

  public static BufferedWriter out;

  public static void ReInit(InputStream instream, File file) {
    Normaliser.ReInit(instream);
    brackets = 0;
    lineNo = 1;
    counter = 0;
    startOfNewLine = true;
    wasspace=false;
    outputFile = file;
  }

  public static void main(String[] args) {
    if (args.length != 2) {
      System.err.println("Usage: java Normaliser <inputFile> <outputFile>");
      System.exit(1);
    }
    Normaliser parser = new Normaliser(System.in);
    try {
      parser.ReInit(new FileInputStream(new File(args[0])), new File(args[1]));
      parser.Input();
    }
    catch (Exception e) {
      System.out.println("Exception caught: " + e);
      e.printStackTrace(System.out);
      System.exit(2);
    }
  }

  public static void write(String s, boolean newline) {
    if (s.equals(" "))
      wasspace = true;
    else wasspace = false;
    startOfNewLine = newline;

    try {
      Normaliser.out.write(s);
      if (newline) {
        Normaliser.out.newLine();

        //output line number in every 10 not-comment lines in the new file.
        counter++;
        if (counter > MAX) {
          counter = 0;
          //write("#line " + lineNo, true);
        }
      }
    }
    catch (IOException e) {
      //System.err.println("IOException caught: " + e);
      Date day = new Date(System.currentTimeMillis());
      try {
          String file = new String
              (System.getProperty("user.home") + Settings.fileSep
               + "sherlock.log");
          BufferedWriter bw = new BufferedWriter
              (new FileWriter(file, true));
          bw.write(day + "-" + "Cannot write to: "
                   + outputFile.getAbsolutePath());
          bw.newLine();
          bw.close();
      }
      catch (IOException e2) {
          System.err.println(day + "-" + "Cannot write to: "
                             + outputFile.getAbsolutePath());
      }
    }
  }

  static final public void matchLine() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_BRACKET:
      jj_consume_token(OPEN_BRACKET);
    Normaliser.brackets++;
    Normaliser.write(token.image, false);
    //consumes all spaces after an open bracket.
    while (getToken(1).kind == SPACE)
      getNextToken();
      break;
    case CLOSE_BRACKET:
      jj_consume_token(CLOSE_BRACKET);
    Normaliser.brackets--;
    Normaliser.write(token.image, false);

    //consume all spaces and new line characters.
    while (getToken(1).kind == SPACE)
      getNextToken();

    //correct syntax is assumed here, ie. no missing ";"s.
    //if not method call or data access, neither end of one statement
    //and brackets in the same line are matched, not a new line,
    //not an operator, not in an array definition, not braces,
    //print line break.
    if (!getToken(1).image.equals(".") && getToken(1).kind != SEMICOLON
        && Normaliser.brackets == 0 && getToken(1).kind != NEWLINE
        && getToken(1).kind != OPERATOR && !getToken(1).image.equals("]")
        && getToken(1).kind != BRACES)
        Normaliser.write("", true);
      break;
    case BRACES:
      jj_consume_token(BRACES);
    if (!wasspace && !startOfNewLine)
      Normaliser.write(" ", false);
    Normaliser.write(token.image, false);
    //consumes all spaces followed.
    while(getToken(1).kind == SPACE)
      getNextToken();

    if (getToken(1).kind == NEWLINE) {
      Normaliser.lineNo++;
      getNextToken();
    }

    //if a semicolon is followed, print the semicolon and then a new line
    //if necessary, otherwise, print new line directly.
    if (getToken(1).kind != SEMICOLON)
      Normaliser.write("", true);
      break;
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
//    Normaliser.write(token.image, true);
    //consume the spaces after an operator.
    while(getToken(1).kind == SPACE || getToken(1).kind == NEWLINE) {
      if (getToken(1).kind == NEWLINE)
        Normaliser.lineNo++;
      getNextToken();
    }
    Normaliser.write(";", true);
      break;
    case INC_OPT:
      jj_consume_token(INC_OPT);
    Normaliser.write(Normaliser.token.image, false);
    //consume the spaces after an operator.
    while(Normaliser.getToken(1).kind == SPACE)
      getNextToken();
      break;
    case NOT_OPT:
      jj_consume_token(NOT_OPT);
    Normaliser.write(Normaliser.token.image + " ", false);
    //consume the spaces after an operator.
    while(Normaliser.getToken(1).kind == SPACE)
      getNextToken();
      break;
    case OPERATOR:
      jj_consume_token(OPERATOR);
    if (!wasspace)
      Normaliser.write(" ", false);
    if (Normaliser.token.image.equals("&&")
        || Normaliser.token.image.equals("||"))
      Normaliser.write("", true);
    Normaliser.write(Normaliser.getToken(0).image + " ", false);
    //consume the spaces after an operator.
    while(Normaliser.getToken(1).kind == SPACE)
      getNextToken();
      break;
    case CAST:
      jj_consume_token(CAST);
    StringBuffer modified = new StringBuffer();
    for (int i = 0; i < token.image.length(); i++) {
      if (token.image.charAt(i) != ' ' && token.image.charAt(i) != '\n')
        modified.append(token.image.charAt(i));
    }
    Normaliser.write(modified.toString(), false);
    //consume the spaces after an operator.
    while(Normaliser.getToken(1).kind == SPACE)
      getNextToken();
      break;
    case SPACE:
      jj_consume_token(SPACE);
    if (!startOfNewLine && !wasspace
        && getToken(1).kind != OPERATOR && getToken(1).kind != CLOSE_BRACKET
        && getToken(1).kind != SEMICOLON)
      Normaliser.write(" ", false);
      break;
    case NEWLINE:
      jj_consume_token(NEWLINE);
    Normaliser.lineNo++;
    while (getToken(1).kind == SPACE || getToken(1).kind == NEWLINE) {
      if (getToken(1).kind == NEWLINE)
        Normaliser.lineNo++;
      getNextToken();
    }

    if(!wasspace && !startOfNewLine && getToken(1).kind != SEMICOLON
       && getToken(1).kind != OPEN_BRACKET && getToken(1).kind != CLOSE_BRACKET
       && !getToken(1).image.equals(".") && !getToken(1).image.equals("[")
       && !getToken(1).image.equals("]") && getToken(1).kind != BRACES)
        Normaliser.write(" ", false);
      break;
    case SINGLECOMMENT:
      jj_consume_token(SINGLECOMMENT);
  //skip to the next line break. 
    do {
      Normaliser.write(token.image, false);
      getNextToken();
    } while (token.kind != NEWLINE && token.kind != 0);
    if (token.kind == NEWLINE)
      Normaliser.lineNo++;
    //output a new line
    Normaliser.write("", true);
      break;
    case MULTICOMMENTSTART:
      jj_consume_token(MULTICOMMENTSTART);
  //skip to MULTICOMMENTEND
    while (getToken(1).kind != MULTICOMMENTEND && getToken(1).kind != 0) {
      Normaliser.write(token.image, false);
      if (token.kind == NEWLINE)
        Normaliser.lineNo++;
      getNextToken();
    }
//    //output the MULTICOMMENTEND token.
//    Normaliser.write(token.image, true);

      break;
    case MULTICOMMENTEND:
      jj_consume_token(MULTICOMMENTEND);
    while (getToken(1).kind == SPACE)
      getNextToken();

    if (getToken(1).kind == NEWLINE) {
      Normaliser.lineNo++;
      getNextToken();
    }

    Normaliser.write("*/", true);
      break;
    case SQUOTE:
      jj_consume_token(SQUOTE);
  //skip to end of line or single quote.
    do {
      Normaliser.write(token.image, false);
      getNextToken();
    } while (token.kind != SQUOTE && token.kind != 0 && token.kind != NEWLINE);
    if (token.kind == NEWLINE)
      Normaliser.lineNo++;
    //output the single quote or new line
    Normaliser.write(token.image, false);
      break;
    case DQUOTE:
      jj_consume_token(DQUOTE);
  //skip to end of line or double quote.
    do {
      Normaliser.write(token.image, false);
      getNextToken();
    } while (token.kind != DQUOTE && token.kind != 0 && token.kind != NEWLINE);
    if (token.kind == NEWLINE)
      Normaliser.lineNo++;
    //output the closing double qoute or new line.
    Normaliser.write(token.image, false);
      break;
    case LINENO:
      jj_consume_token(LINENO);
      jj_consume_token(NUMBER);
    Normaliser.lineNo = Integer.parseInt(token.image);
      break;
    case NUMBER:
    case DQUOTE_ESCAPE:
    case SQUOTE_ESCAPE:
    case OTHER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OTHER:
        jj_consume_token(OTHER);
        break;
      case SQUOTE_ESCAPE:
        jj_consume_token(SQUOTE_ESCAPE);
        break;
      case DQUOTE_ESCAPE:
        jj_consume_token(DQUOTE_ESCAPE);
        break;
      case NUMBER:
        jj_consume_token(NUMBER);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    Normaliser.write(token.image, false);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Input() throws ParseException {
  try {
    if (outputFile != null)
       Normaliser.out = new BufferedWriter(new FileWriter(outputFile));
    else Normaliser.out = new BufferedWriter(new OutputStreamWriter
                                               (System.out));
  }
  catch (IOException e) {
      Date day = new Date(System.currentTimeMillis());
      if (outputFile != null) {
        try {
            String file = new String
                (System.getProperty("user.home") + Settings.fileSep
                 + "sherlock.log");
            BufferedWriter bw = new BufferedWriter
                (new FileWriter(file, true));
            bw.write(day + "-" + "Cannot write to: "
                     + outputFile.getAbsolutePath());
            bw.newLine();
            bw.close();
        }
        catch (IOException e2) {
            if (outputFile != null)
                System.err.println(day + "-" + "Cannot write to: "
                                   + outputFile.getAbsolutePath());
        }
      }
      else System.err.println(day + "-" + "Cannot write to System.out");
      return;
  }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_BRACKET:
      case CLOSE_BRACKET:
      case BRACES:
      case SEMICOLON:
      case INC_OPT:
      case NOT_OPT:
      case OPERATOR:
      case CAST:
      case LINENO:
      case NUMBER:
      case SPACE:
      case NEWLINE:
      case DQUOTE:
      case SQUOTE:
      case DQUOTE_ESCAPE:
      case SQUOTE_ESCAPE:
      case OTHER:
      case SINGLECOMMENT:
      case MULTICOMMENTSTART:
      case MULTICOMMENTEND:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      matchLine();
    }
    jj_consume_token(0);
    try {
      Normaliser.out.flush();
      Normaliser.out.close();
    }
    catch(IOException e) {
      Date day = new Date(System.currentTimeMillis());
      if (outputFile != null) {
        try {
            String file = new String
                (System.getProperty("user.home") + Settings.fileSep
                 + "sherlock.log");
            BufferedWriter bw = new BufferedWriter
                (new FileWriter(file, true));
            bw.write(day + "-" + "Cannot write to: "
                     + outputFile.getAbsolutePath());
            bw.newLine();
            bw.close();
        }
        catch (IOException e2) {
            if (outputFile != null)
                System.err.println(day + "-" + "Cannot write to: "
                                   + outputFile.getAbsolutePath());
        }
      }
      else System.err.println(day + "-" + "Cannot write to System.out");
      {if (true) return;}
    }
  }

  static private boolean jj_initialized_once = false;
  static public NormaliserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[3];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x708000,0x3ffcff0,0x3ffcff0,};
   }

  public Normaliser(java.io.InputStream stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new NormaliserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  public Normaliser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new NormaliserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  public Normaliser(NormaliserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  public void ReInit(NormaliserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  static public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[26];
    for (int i = 0; i < 26; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 3; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 26; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

}
